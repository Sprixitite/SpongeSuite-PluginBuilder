<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBX3C6AC9E10E734629A19F7E74369C83C8">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">SpongeSuite-PluginBuilder</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="ModuleScript" referent="RBX213299003680436A81C315BBCD81C1EA">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[local GithubAPI = {}

local function InvalidConfig(badField)
	error("GithubAPI : Config Invalid : " .. badField .. " was left unset!")
end

GithubAPI.Config = {
	HttpGet = function(url)
		InvalidConfig("HttpGet")
	end,
	Json2Table = function(json)
		InvalidConfig("Json2Table")
	end,
}

GithubAPI.Repo = {}
GithubAPI.RepoDir = {}

local function newObjectFactory(
	typeName,
	fields,
	vtable,
	meta
)
	vtable = vtable or {}
	meta = meta or {}
	local validObjects = setmetatable( {}, { __mode = 'k' } )
	local fieldN = #fields
	
	local constructor = function(...)
		local vararg = { ... }
		local newObj = setmetatable( {}, meta )
		
		for i=1, fieldN do
			newObj[ fields[i] ] = vararg[i]
		end
		
		for fname, f in pairs(vtable) do
			newObj[fname] = f
		end
		
		validObjects[newObj] = true
		
		return newObj
	end
	
	local validator = function(obj)
		if validObjects[obj] ~= true then
			error("Provided " .. typeName .. " " .. tostring(obj) .. " is invalid!")
		end
	end
	
	return constructor, validator
end

function GithubAPI.Repo.ToString(repo)
	return "[ Github Repo \"" .. repo.Name .. "\" by \"" .. repo.Owner .. "\" ]"
end

function GithubAPI.Repo.GetFolder(repo, path)
	return GithubAPI.RepoDir.FromElements(repo.Owner, repo.Name, repo.Branch, path)
end

GithubAPI.Repo.FromElements, GithubAPI.Repo.Validate = newObjectFactory(
	"Repo",
	{ "Owner", "Name", "Branch" },
	{
		GetFolder = GithubAPI.Repo.GetFolder
	},
	{
		__tostring = GithubAPI.Repo.ToString
	}
)

function GithubAPI.Repo.FromURL(url)
	local owner, repoName = string.match(url, "github.com/([^/]+)/([^/]+)")
	local branch = string.match(url, "github.com/([^/]+)/([^/]+)/tree/([^/]+)")
	
	if branch == nil then branch = "main" end
	
	if owner == nil or repoName == nil then
		error("Given github repo URL \"" .. url .. "\" is invalid!")
	end
	
	return GithubAPI.Repo.FromElements(owner, repoName, branch)
end

function GithubAPI.RepoDir.ToString(repoDir)
	return "[ Github Repo Dir \"" .. repoDir.Path .. "\" in repo \"" .. repoDir.Name .. "\" by \"" .. repoDir.Owner .. "\" ]"
end

function GithubAPI.RepoDir.ToContentUrl(repoDir)
	return "https://api.github.com/repos/" .. repoDir.Owner .. '/' .. repoDir.Name .. "/contents/" .. repoDir.Path .. "?ref=" .. repoDir.Branch
end

function GithubAPI.RepoDir.GetContentsInfo(repoDir)
	if repoDir.CachedContents ~= nil then
		return repoDir.CachedContents
	end
	
	local success, json = pcall(
		GithubAPI.Config.HttpGet,
		repoDir:ToContentUrl()
	)
	
	if not success then
		error("GithubAPI : Failed to retrieve contents of \"" .. tostring(repoDir) .. "\"! Inner error was as follows: " .. json)
	end
	
	local success, contents = pcall(
		GithubAPI.Config.Json2Table,
		json
	)
	
	if not success then
		error("GithubAPI : Failed to convert JSON to table! Inner error was as follows: " .. contents)
	end
	
	repoDir.CachedContents = contents
	return contents
end

function GithubAPI.RepoDir.GetFile(repoDir, filename)
	return pcall(
		GithubAPI.Config.HttpGet,
		"https://raw.githubusercontent.com/" .. repoDir.Owner .. '/' .. repoDir.Name .. '/' .. repoDir.Branch .. '/' .. repoDir.Path .. '/' .. filename
	)
end

GithubAPI.RepoDir.FromElements, GithubAPI.RepoDir.Validate = newObjectFactory(
	"RepoDir",
	{ "Owner", "Name", "Branch", "Path" },
	{
		GetFile = GithubAPI.RepoDir.GetFile,
		ToContentUrl = GithubAPI.RepoDir.ToContentUrl,
		GetContentsInfo = GithubAPI.RepoDir.GetContentsInfo
	},
	{
		__tostring = GithubAPI.RepoDir.ToString
	}
)

function GithubAPI.RepoDir.FromURLAndPath(url, path)
	return GithubAPI.Repo.FromURL(url):GetFolder(path)
end

return GithubAPI]]></ProtectedString>
				<string name="ScriptGuid">{7AB3130B-B6A1-4F55-819A-8961F0BA6672}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">GithubAPI</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX7C48A800AFB24A8584F295394CC18FE0">
			<Properties>
				<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")

local githubAPI = require("./GithubAPI")
githubAPI.Config.HttpGet = function(url)
	return HttpService:GetAsync(url)
end

githubAPI.Config.Json2Table = function(json)
	return HttpService:JSONDecode(json)
end

local prompter = require("./UI/Prompts")
prompter.Init()

local toolbar = plugin:CreateToolbar("PluginBuilder")

local buildBtn = toolbar:CreateButton(
	"SpongeSuite_PluginBuilder_BuildRemotePlugin",
	"Build a plugin located in a github repository",
	"rbxassetid://131891286031534",
	"Build Remote Plugin"
)

local function githubAPIToDataModel(repoRoot, repoDirPath, dataModelParent)
	local repoDir = repoRoot:GetFolder(repoDirPath)
	local folderContents = repoDir:GetContentsInfo()
	
	for _, entry in ipairs(folderContents) do
		task.spawn(function()
			if entry.type == "file" then
				local isModule = (string.match(entry.name, "%.server%.lua$") == nil)
				local inst = (isModule and Instance.new("ModuleScript")) or Instance.new("Script")
				local name = string.gsub(entry.name, "%.lua$", ""):gsub("%.server$", "")
				inst.Name = name
				inst.Parent = dataModelParent
				inst:AddTag(`Remote_{repoRoot.Name}`)
				
				print(`PluginBuilder : Retrieving file {name}...`)
				local success, source = repoDir:GetFile(entry.name)
				
				if not success then
					warn(`PluginBuilder : Failed to retrieve file {name} : ` .. source)
					inst.Source = `error("Failed to retrieve file from remote repository!")`
				else
					inst.Source = source
				end
			elseif entry.type == "dir" then
				local f = Instance.new("Folder")
				f.Name = entry.name
				f.Parent = dataModelParent
				f:AddTag(`Remote_{repoRoot.Name}`)
				
				githubAPIToDataModel(repoRoot, entry.path, f)
			else
				warn(`PluginBuilder : Encountered remote file of unknown type "{entry.type}"! File will be ignored`)
			end
		end)
	end
	
end

local function buildPlugin()
	local cont, url = prompter.String("Repo URL", "https://github.com/Author/Repo")
	if not cont then return end
	
	url = url:gsub("/+$", "")
	
	local cont, path = prompter.String("Plugin Path", "Plugins/src/CoolPlugin")
	if not cont then return end
	
	path = path:gsub("^/+", ""):gsub("/+$", "")
	
	local cont, outName = prompter.String("Plugin Name", "CoolPlugin")
	if not cont then return end
	
	local repo = githubAPI.Repo.FromURL(url)
	local outFolder = Instance.new("Folder")
	outFolder.Name = outName
	
	githubAPIToDataModel(repo, path, outFolder)
	
	local attribution = Instance.new("ModuleScript")
	attribution.Name = "@__PluginBuilderAttribution__@"
	attribution.Source = "-- This plugin was automatically built with Sprixitite's \"SpongeSuite-PluginBuilder\"" .. '\n' ..
						 "-- The plugin may be found at the following link: " .. "https://www.github.com/Sprixitite/SpongeSuite-PluginBuilder" .. "\n\n" ..
						 "-- ATTENTION: Removal of this attribution notice for redistribution violates the plugin's terms of use" .. '\n' .. 
						 "error('Attempt to require SpongeSuite-PluginBuilder attribution notice!')"
	attribution.Parent = outFolder
	
	outFolder.Parent = game.ReplicatedStorage
	game.Selection:Set({outFolder})
end

local doingSomething = false
local function btn_pressed()
	if doingSomething then
		doingSomething = false
		prompter.CancelAll()
		return
	end
	doingSomething = true
	buildPlugin()
	doingSomething = false
end

buildBtn.Click:Connect(btn_pressed)]]></ProtectedString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<token name="RunContext">3</token>
				<string name="ScriptGuid">{914A072D-DAFF-48BB-808D-C303050BB8BE}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Main</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBXA06127A8BC9144918350F45E59AFA49D">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">UI</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX7D6E016BA2FF4EF29E260BFA591B1F46">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local CoreGui = game:GetService("CoreGui")
local themeLoader = require("./Themes/Loader")
local theme_Sponge = require("./Themes/SpongeSuite")
local theme_Sponge_Tok = require("./Themes/SpongeSuiteTokens")

local Prompts = {}

local templates = {}
local prompters = {}

local cancel = Instance.new("BindableEvent")

local function prompterEntry(name, ui, event)
	prompters[name] = {
		UI = ui,
		Event = event
	}
end

local function createPrompter(id, ui)
	if CoreGui:FindFirstChild(ui.Name) ~= nil then
		CoreGui[ui.Name]:Destroy()
	end
	
	local event  = Instance.new("BindableEvent")
	ui.Archivable = false
	
	prompterEntry(id, ui, event)
end

local function NewUIElem(id, elemScript, stylesheet)
	templates[id] = require(elemScript)
	
	local link = Instance.new("StyleLink")
	link.Parent = templates[id]
	link.StyleSheet = stylesheet
end

local function StyleInit()
	local spongeStyle = themeLoader.ReconstructSheet( theme_Sponge )
	spongeStyle.Archivable = false
	
	if CoreGui:FindFirstChild(spongeStyle.Name) ~= nil then
		CoreGui[spongeStyle.Name]:Destroy()
	end
	
	spongeStyle.Parent = CoreGui
	
	local derive = Instance.new("StyleDerive")
	derive.Parent = spongeStyle
	
	local spongeStyleTok = themeLoader.ReconstructSheet( theme_Sponge_Tok )
	spongeStyleTok.Archivable = false
	
	if CoreGui:FindFirstChild(spongeStyleTok.Name) ~= nil then
		CoreGui[spongeStyleTok.Name]:Destroy()
	end
	
	spongeStyleTok.Parent = CoreGui
	derive.StyleSheet = spongeStyleTok
	
	NewUIElem("String", script.Parent.UIElems.TextInput, spongeStyle)
end

function Prompts.Init()
	StyleInit()
	createPrompter("String", templates.String)
	
	local strUI = prompters.String.UI
	local entryBox   = strUI:FindFirstChild("EntryBox", true)
	local confirmBtn = strUI:FindFirstChild("ConfirmButton", true)
	local cancelBtn  = strUI:FindFirstChild("CancelButton", true)
	
	confirmBtn.MouseButton1Click:Connect(function()
		prompters.String.Event:Fire(true, entryBox.Text)
	end)
	
	cancelBtn.MouseButton1Click:Connect(function()
		prompters.String.Event:Fire(false, nil)
	end)
	
	cancel.Event:Connect(function()
		prompters.String.Event:Fire(false, nil)
	end)
end

function Prompts.CancelAll()
	cancel:Fire()
end

function Prompts.String(entering, default)
	local ui = prompters.String.UI
	while ui.Parent ~= nil do
		ui.AncestryChanged:Wait()
	end
	
	local heading = ui:FindFirstChild("Heading", true)
	local defaultHeading = heading.Text
	heading.Text = string.gsub(defaultHeading, "{}", entering)
	
	local enterBox = ui:FindFirstChild("EntryBox", true)
	enterBox.PlaceholderText = default
	enterBox.Text = ""
	
	ui.Parent = CoreGui
	
	local succeeded, entered = prompters.String.Event.Event:Wait()
	
	heading.Text = defaultHeading
	ui.Parent = nil
	
	return succeeded, entered
end

return Prompts]]></ProtectedString>
					<string name="ScriptGuid">{5FE88E45-94E1-4E7C-9F70-C0CB6D15D5CE}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Prompts</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBXF82CC341A607499E94476AD7C697BB0C">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Themes</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXD8F9F3156DCD4B9CB3BAF7B74DCD5E28">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[return {
	Attributes={
	
	},
	Name="SpongeSuite",
	Rules={
	{
		Children={
		
		},
		Name="Frame",
		Priority=2,
		Props={
			BackgroundTransparency=1
		},
		Selector="Frame"
	},
	{
		Children={
		
		},
		Name=".Solid",
		Priority=4,
		Props={
			BackgroundColor3="$BackgroundColor",
			BackgroundTransparency=0
		},
		Selector=".Solid"
	},
	{
		Children={
		{
			Children={
			
			},
			Name="::UITextSizeConstraint",
			Priority=2,
			Props={
				MaxTextSize=18,
				MinTextSize=14
			},
			Selector="::UITextSizeConstraint"
		}
		},
		Name="TextLabel",
		Priority=0,
		Props={
			BackgroundTransparency=1,
			FontFace=Font.new("rbxasset://fonts/families/Zekton.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),
			TextColor3="$TextColor",
			TextSize=16
		},
		Selector="TextLabel"
	},
	{
		Children={
		{
			Children={
			
			},
			Name="::UICorner",
			Priority=1,
			Props={
				CornerRadius=UDim.new(0, 4)
			},
			Selector="::UICorner"
		},
		{
			Children={
			
			},
			Name="::UITextSizeConstraint",
			Priority=2,
			Props={
				MaxTextSize=18,
				MinTextSize=14
			},
			Selector="::UITextSizeConstraint"
		}
		},
		Name="TextButton",
		Priority=1,
		Props={
			BackgroundColor3="$BackgroundAltColor",
			FontFace=Font.new("rbxasset://fonts/families/Zekton.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),
			TextColor3="$TextColor"
		},
		Selector="TextButton"
	},
	{
		Children={
		
		},
		Name=".Pos",
		Priority=6,
		Props={
			BackgroundColor3=Color3.new(0.016260147094726562, 1, 0.5429089069366455),
			TextColor3=Color3.new(0.125490203499794, 0.125490203499794, 0.125490203499794)
		},
		Selector=".Pos"
	},
	{
		Children={
		
		},
		Name=".Neg",
		Priority=8,
		Props={
			BackgroundColor3=Color3.new(1, 0, 0.4343433380126953),
			TextColor3=Color3.new(0.125490203499794, 0.125490203499794, 0.125490203499794)
		},
		Selector=".Neg"
	},
	{
		Children={
		{
			Children={
			
			},
			Name="::UITextSizeConstraint",
			Priority=1,
			Props={
				MaxTextSize=22,
				MinTextSize=18
			},
			Selector="::UITextSizeConstraint"
		}
		},
		Name=".H1",
		Priority=10,
		Props={
			FontFace=Font.new("rbxasset://fonts/families/Zekton.json", Enum.FontWeight.Bold, Enum.FontStyle.Normal),
			TextScaled=true
		},
		Selector=".H1"
	},
	{
		Children={
		{
			Children={
			
			},
			Name="::UITextSizeConstraint",
			Priority=1,
			Props={
				MaxTextSize=20,
				MinTextSize=16
			},
			Selector="::UITextSizeConstraint"
		}
		},
		Name=".H2",
		Priority=9,
		Props={
			TextScaled=true
		},
		Selector=".H2"
	},
	{
		Children={
		{
			Children={
			
			},
			Name="::UIPadding",
			Priority=1,
			Props={
				PaddingBottom=UDim.new(0, 4),
				PaddingLeft=UDim.new(0, 4),
				PaddingRight=UDim.new(0, 4),
				PaddingTop=UDim.new(0, 4)
			},
			Selector="::UIPadding"
		}
		},
		Name=".Pad",
		Priority=7,
		Props={
		
		},
		Selector=".Pad"
	},
	{
		Children={
		{
			Children={
			
			},
			Name="::UICorner",
			Priority=1,
			Props={
				CornerRadius=UDim.new(0, 4)
			},
			Selector="::UICorner"
		}
		},
		Name=".Round",
		Priority=5,
		Props={
		
		},
		Selector=".Round"
	},
	{
		Children={
		{
			Children={
			
			},
			Name="::UITextSizeConstraint",
			Priority=2,
			Props={
				MaxTextSize=18,
				MinTextSize=14
			},
			Selector="::UITextSizeConstraint"
		},
		{
			Children={
			
			},
			Name="::UICorner",
			Priority=1,
			Props={
				CornerRadius=UDim.new(0, 4)
			},
			Selector="::UICorner"
		},
		{
			Children={
			{
				Children={
				
				},
				Name="::UICorner",
				Priority=1,
				Props={
					CornerRadius=UDim.new(0, 4)
				},
				Selector="::UICorner"
			},
			{
				Children={
				
				},
				Name=".Solid",
				Priority=2,
				Props={
				
				},
				Selector=".Solid"
			}
			},
			Name=">Frame",
			Priority=3,
			Props={
				AnchorPoint=Vector2.new(0.5, nil),
				BackgroundColor3="$AccentColor",
				BackgroundTransparency=0,
				Position=UDim2.new(0.5, 0, 1, -4),
				Size=UDim2.new(1, -8, 0, 2)
			},
			Selector=">Frame"
		}
		},
		Name="TextBox",
		Priority=3,
		Props={
			BackgroundColor3="$BackgroundAltColor",
			FontFace=Font.new("rbxasset://fonts/families/Zekton.json", Enum.FontWeight.Regular, Enum.FontStyle.Normal),
			PlaceholderColor3=Color3.new(0.8745098114013672, 0.8745098114013672, 0.8745098114013672),
			TextColor3="$TextColor",
			TextTruncate=Enum.TextTruncate.AtEnd
		},
		Selector="TextBox"
	}
	}
}]]></ProtectedString>
						<string name="ScriptGuid">{00DF575A-C489-41CF-8216-55B4951735B8}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">SpongeSuite</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXCE75D5E6A3244797A12E9B9C40465FAD">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[return {
	Attributes={
		AccentColor=Color3.new(0.01568627543747425, 1, 0.5411764979362488),
		BackgroundAltColor=Color3.new(0.125490203499794, 0.125490203499794, 0.125490203499794),
		BackgroundColor=Color3.new(0, 0, 0),
		StyleCategory="Tokens",
		TextColor=Color3.new(1, 1, 1)
	},
	Name="SpongeSuiteTokens",
	Rules={
	
	}
}]]></ProtectedString>
						<string name="ScriptGuid">{BE09DDF4-1E86-4DED-B8C4-07ACADF899C7}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">SpongeSuiteTokens</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXFC9B14BF4AE84518825BE8B34E203EEF">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local loader = {}

function loader.ReconstructRules(tbl)
	local rule = Instance.new("StyleRule")
	rule.Name = tbl.Name
	rule.Priority = tbl.Priority
	rule.Selector = tbl.Selector
	rule:SetProperties(tbl.Props)
	
	for _, child in ipairs(tbl.Children) do
		local childRule = loader.ReconstructRules(child)
		childRule.Parent = rule
	end

	return rule
end

function loader.ReconstructSheet(tbl)
	local sheet = Instance.new("StyleSheet")
	
	sheet.Name = tbl.Name
	for attrName, attrVal in pairs(tbl.Attributes) do
		sheet:SetAttribute(attrName, attrVal)
	end
	
	for _, rule in ipairs(tbl.Rules) do
		local inst = loader.ReconstructRules(rule)
		inst.Parent = sheet
	end
	
	return sheet
end

return loader]]></ProtectedString>
						<string name="ScriptGuid">{F9F6F0BE-4120-4FDE-8A1A-BB21E3F65F43}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Loader</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX812F7621057743BBB99DAAC8B01F5AFF">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">UIElems</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX38A7AECC371B42089863F37DC382C040">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--[=[
 d888b  db    db d888888b      .d888b.      db      db    db  .d8b.  
88' Y8b 88    88   `88'        VP  `8D      88      88    88 d8' `8b 
88      88    88    88            odD'      88      88    88 88ooo88 
88  ooo 88    88    88          .88'        88      88    88 88~~~88 
88. ~8~ 88b  d88   .88.        j88.         88booo. 88b  d88 88   88    @uniquadev
 Y888P  ~Y8888P' Y888888P      888888D      Y88888P ~Y8888P' YP   YP  CONVERTER 
]=]

-- Instances: 8 | Scripts: 0 | Modules: 0 | Tags: 6
local CollectionService = game:GetService("CollectionService");
local G2L = {};

-- Workspace.SpongeSuite-PluginArchitect.UI.TextInput
G2L["1"] = Instance.new("ScreenGui");
G2L["1"]["Name"] = [[TextInput]];
G2L["1"]["ZIndexBehavior"] = Enum.ZIndexBehavior.Sibling;


-- Workspace.SpongeSuite-PluginArchitect.UI.TextInput.BG
G2L["2"] = Instance.new("Frame", G2L["1"]);
G2L["2"]["BorderSizePixel"] = 0;
G2L["2"]["AnchorPoint"] = Vector2.new(0.5, 0.5);
G2L["2"]["Size"] = UDim2.new(0.5, 0, 0.25, 0);
G2L["2"]["Position"] = UDim2.new(0.5, 0, 0.5, 0);
G2L["2"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2"]["Name"] = [[BG]];
G2L["2"]["BackgroundTransparency"] = 0.25;

-- Tags
CollectionService:AddTag(G2L["2"], [[Solid]]);

-- Workspace.SpongeSuite-PluginArchitect.UI.TextInput.BG.ConfirmButton
G2L["3"] = Instance.new("TextButton", G2L["2"]);
G2L["3"]["BorderSizePixel"] = 0;
G2L["3"]["TextSize"] = 14;
G2L["3"]["AnchorPoint"] = Vector2.new(0, 1);
G2L["3"]["Size"] = UDim2.new(0.5, -8, 0.33, -8);
G2L["3"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3"]["Text"] = [[Confirm]];
G2L["3"]["Name"] = [[ConfirmButton]];
G2L["3"]["Position"] = UDim2.new(0, 4, 1, -4);

-- Tags
CollectionService:AddTag(G2L["3"], [[Pos]]);
CollectionService:AddTag(G2L["3"], [[H2]]);

-- Workspace.SpongeSuite-PluginArchitect.UI.TextInput.BG.CancelButton
G2L["4"] = Instance.new("TextButton", G2L["2"]);
G2L["4"]["BorderSizePixel"] = 0;
G2L["4"]["TextSize"] = 14;
G2L["4"]["AnchorPoint"] = Vector2.new(1, 1);
G2L["4"]["Size"] = UDim2.new(0.5, -8, 0.33, -8);
G2L["4"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4"]["Text"] = [[Cancel]];
G2L["4"]["Name"] = [[CancelButton]];
G2L["4"]["Position"] = UDim2.new(1, -4, 1, -4);

-- Tags
CollectionService:AddTag(G2L["4"], [[Neg]]);
CollectionService:AddTag(G2L["4"], [[H2]]);

-- Workspace.SpongeSuite-PluginArchitect.UI.TextInput.BG.Heading
G2L["5"] = Instance.new("TextLabel", G2L["2"]);
G2L["5"]["BorderSizePixel"] = 0;
G2L["5"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["5"]["Size"] = UDim2.new(1, 0, 0.33, 0);
G2L["5"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["5"]["Text"] = [[Enter {}:]];
G2L["5"]["Name"] = [[Heading]];

-- Tags
CollectionService:AddTag(G2L["5"], [[H1]]);

-- Workspace.SpongeSuite-PluginArchitect.UI.TextInput.BG.EntryBox
G2L["6"] = Instance.new("TextBox", G2L["2"]);
G2L["6"]["Name"] = [[EntryBox]];
G2L["6"]["BorderSizePixel"] = 0;
G2L["6"]["TextSize"] = 14;
G2L["6"]["AnchorPoint"] = Vector2.new(0.5, 0);
G2L["6"]["PlaceholderText"] = [[Placeholder Text]];
G2L["6"]["Size"] = UDim2.new(1, -8, 0.33, 0);
G2L["6"]["Position"] = UDim2.new(0.5, 0, 0.33, 0);
G2L["6"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["6"]["Text"] = [[]];


-- Workspace.SpongeSuite-PluginArchitect.UI.TextInput.BG.EntryBox.Frame
G2L["7"] = Instance.new("Frame", G2L["6"]);
G2L["7"]["BorderSizePixel"] = 0;
G2L["7"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);

return G2L["1"]]]></ProtectedString>
						<string name="ScriptGuid">{96F289A7-8AE4-4AFD-9C95-91BA9B4E19B7}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">TextInput</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX95814C12B1B042DFB01EF0752680F783">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">StyleWriter</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX0BFAD3E32D4248269EE3F9086AA4CE3C">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[-- This file is used to convert the "SpongeSuite" stylesheet into a module for upload to github as code
-- It is not used in the actual plugin

local tableWriter = require("./TableWriter")

local function write_enum(enum: EnumItem)
	local enumName
	for _, e in ipairs(Enum:GetEnums()) do
		if e == enum.EnumType then
			enumName = e
			break
		end
	end

	return `Enum.{enumName}.{enum.Name}`
end

local function write_font(font: Font)
	return `Font.new("{font.Family}", {write_enum(font.Weight)}, {write_enum(font.Style)})`
end

local function write_color3(color: Color3)
	return `Color3.new({color.R}, {color.G}, {color.B})`
end

local function write_udim(udim: UDim)
	return `UDim.new({udim.Scale}, {udim.Offset})`
end

local function write_udim2(udim2: UDim2)
	return `UDim2.new({udim2.X}, {udim2.Y})`
end

local function write_vec2(vec2: Vector2)
	return `Vector2.new({vec2.X}, {Vector2.Y})`
end

local function write_vec3(vec3: Vector3)
	return `Vector3.new({vec3.X}, {vec3.Y}, {vec3.Z})`
end

local function get_style_rules(root)
	local childData = {}
	for _, rule in ipairs(root:GetChildren()) do
		if not rule:IsA("StyleRule") then continue end
		childData[#childData + 1] = {
			Props = rule:GetProperties(),
			Priority = rule.Priority,
			Name = rule.Name,
			Selector = rule.Selector,
			Children = get_style_rules(rule)
		}
	end
	return childData
end

tableWriter.configure{
	warn = warn,
	type = typeof,
	userdata_value_writers = {
		UDim = write_udim,
		UDim2 = write_udim2,
		Color3 = write_color3,
		Font = write_font,
		Vector2 = write_vec2,
		Vector3 = write_vec3,
		EnumItem = write_enum,
	}
}

local styleWriter = {}

function styleWriter.WriteStyle(style)
	return tableWriter.write_tbl{
		Name = style.Name,
		Rules = get_style_rules(style),
		Attributes = style:GetAttributes()
	}
end

return styleWriter]]></ProtectedString>
					<string name="ScriptGuid">{7AB0DF4C-6EFC-41C6-A608-E951D1A5E076}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Main</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX55D427FF3EDB4FCFAB745C423E8B552C">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local TableWriter = {}

local tableWriterCfg = {
	type = type,
	warn = function(...) print("WARNING ", ...) end,
	error = error,
	userdata_value_writers = {}
}

local valueWriters = {
	string = function(v)
		return "\"" .. tostring(v):gsub("\\", "\\\\"):gsub("\n", "\\n"):gsub("\t", "\\t"):gsub("\r", "\\r"):gsub("\v", "\\v"):gsub("\f", "\\f"):gsub("\"", "\\\""):gsub("\'", "\\\'") .. "\""
	end,
	table = function(v)
		return TableWriter.write_tbl(v)
	end,
	number = function(v)
		return tostring(v)
	end,
	boolean = function(v)
		return tostring(v)
	end,
	["nil"] = function(v)
		return "nil"
	end,
}

local keyWriters = {
	string = function(k)
		if k:match("^[_%a][_%w]+$") then
			return k
		else
			return '[' .. valueWriters.string(k) .. ']' 
		end
	end,
	boolean = function(k)
		return '[' .. tostring(k) .. ']'
	end,
	number = function(k)
		return '[' .. tostring(k) .. ']'
	end,
	["nil"] = function(k)
		return "[nil]"
	end,
}

local function isValidArrayIndex(value)
	if type(value) ~= "number" then return false end
	if value < 1 then return false end
	return math.round(value) == value
end

function TableWriter.write_key(k)
	local kType = tableWriterCfg.type(k)
	local writer = keyWriters[kType]
	if writer then return writer(k) end
	tableWriterCfg.error("Attempt to write " .. kType .. " as key")
end

function TableWriter.write_value(v)
	local vType = tableWriterCfg.type(v)
	local writer = valueWriters[vType]
	writer = writer or tableWriterCfg.userdata_value_writers[vType]
	if writer then return writer(v) end
	tableWriterCfg.error("Attempt to write " .. vType .. " as value")
end

function TableWriter.write_kvp(k, v)
	local kStr = TableWriter.write_key(k)
	local vStr = TableWriter.write_value(v)
	return kStr .. '=' .. vStr
end

function TableWriter.is_array(tbl)
	local is_arr = true
	local i = 0
	for k, _ in pairs(tbl) do
		i = i + 1
		if (not isValidArrayIndex(k)) or (k ~= i) then
			is_arr = false
			break
		end
	end
	return is_arr
end

function TableWriter.tbl_count(tbl)
	local i = 0
	for _, _ in pairs(tbl) do
		i = i + 1
	end
	return i
end

function TableWriter.write_arr(tbl)
	local str = '{\n'
	for i, v in TableWriter.sorted_iter(tbl) do
		str = str .. TableWriter.write_value(v)
		if i ~= #tbl then str = str .. ',\n' end
	end
	str = str .. '\n}'
	return str
end

function TableWriter.sorted_iter(tbl)
	local keys = {}
	for k, _ in pairs(tbl) do keys[#keys+1] = k end
	table.sort(keys)
	local i = 0
	return function()
		i = i + 1
		if i > #keys then return nil end
		local key = keys[i]
		return key, tbl[key]
	end
end

function TableWriter.write_tbl(tbl)
	if TableWriter.is_array(tbl) then return TableWriter.write_arr(tbl) end

	local n = TableWriter.tbl_count(tbl)
	local i = 0
	local str = '{\n'
	for k, v in TableWriter.sorted_iter(tbl) do
		i = i + 1
		str = str .. "\t" .. TableWriter.write_kvp(k, v):gsub("\n", "\n\t")
		if i ~= n then str = str .. ',\n' end
	end
	str = str .. '\n}'

	return str
end

function TableWriter.configure(tbl)
	for k, v in pairs(tbl) do
		local existingValue = tableWriterCfg[k]
		if existingValue ~= nil then
			tableWriterCfg[k] = v
		else 
			tableWriterCfg.warn("Attempt to set unsupported config key \"" .. k .. "\" = \"" .. tostring(v) .. "\"!")
		end
	end
end

return TableWriter]]></ProtectedString>
					<string name="ScriptGuid">{A7E02B82-FF39-4FBF-B774-4378A1D807F0}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">TableWriter</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
	</Item>
</roblox>